% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/source_EM.R
\name{star_intervals}
\alias{star_intervals}
\title{Compute prediction intervals for the integer-valued response}
\usage{
star_intervals(PI_z, fit_star)
}
\arguments{
\item{PI_z}{\code{n x 2} matrix of prediction intervals/bands for \code{z_star}}

\item{fit_star}{the fitted object from a STAR model; must contain the values of
\code{mu.hat}, \code{sigma.hat}, and \code{lambda} from the MLEs.}
}
\value{
\code{PI_y}: the \code{n x 2} matrix of prediction intervals/bands
}
\description{
Given prediction intervals for \code{z_star}, compute prediction intervals for the counts.
}
\details{
Since the model for \code{z_star} is Gaussian, prediction intervals are readily available
in a variety of settings, such as linear regression, spline regression, and additive regression models.
The coverage for these intervals will propagate to the STAR intervals; similarly, simultaneous
bands may be provided with the same result.
}
\examples{
# Simulate data with count-valued response y:
x = seq(0, 1, length.out = 100)
y = rpois(n = length(x), lambda = exp(1.5 + 5*(x -.5)^2))

# Assume a quadratic effect (better for illustration purposes):
X = cbind(1,x, x^2)

# EM algorithm for STAR (using the log-link)
fit_em = star_EM(y = y,
                 estimator = function(y) lm(y ~ X - 1),
                 transformation = 'box-cox',
                 lambda = 0)

# Latent Gaussian variables at the MLEs:
z_hat = fit_em$z.hat

# Compute prediction intervals for z_star:
PI_z = predict(lm(z_hat ~ X - 1),
               newdata = data.frame(X = X),
               interval = 'prediction',
               level = 0.95)[,-1]

# Using these, compute prediction intervals for STAR:
PI_y = star_intervals(PI_z, fit_em)

# Plot the results: PIs and CIs
plot(x, y, ylim = range(y, PI_y), main = 'STAR: Prediction Intervals')
lines(x, PI_y[,1], col='darkgray', type='s', lwd=4);
lines(x, PI_y[,2], col='darkgray', type='s', lwd=4)
lines(x, fitted(fit_em), lwd=5, col='blue')
lines(x, y, type='p')


}
