% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/source_MCMC.R
\name{bart_star_MCMC}
\alias{bart_star_MCMC}
\title{MCMC Algorithm for BART-STAR Model}
\usage{
bart_star_MCMC(y, X, X_test = NULL, y_test = NULL,
  transformation = "log", lambda = NULL, y_max = Inf,
  n.trees = 200, sigest = NULL, sigdf = 3, sigquant = 0.9, k = 2,
  power = 2, base = 0.95, nsave = 5000, nburn = 5000, nskip = 2,
  verbose = TRUE)
}
\arguments{
\item{y}{\code{n x 1} vector of observed counts}

\item{X}{\code{n x p} matrix of predictors}

\item{X_test}{\code{n0 x p} matrix of predictors for test data}

\item{y_test}{\code{n0 x 1} vector of the test data responses (used for
computing log-predictive scores)}

\item{transformation}{transformation to use for the latent process; must be one of
\itemize{
\item "identity" (identity transformation)
\item "log" (log transformation)
\item "sqrt" (square root transformation)
\item "box-cox" (box-cox transformation)
}}

\item{lambda}{the nonlinear parameter for the Box-Cox transformation; if NULL, model as unknown}

\item{y_max}{a fixed and known upper bound for all observations; default is \code{Inf}}

\item{n.trees}{number of trees to use in BART; default is 200}

\item{sigest}{positive numeric estimate of the residual standard deviation (see ?bart)}

\item{sigdf}{degrees of freedom for error variance prior (see ?bart)}

\item{sigquant}{quantile of the error variance prior that the rough estimate (sigest)
is placed at. The closer the quantile is to 1, the more aggresive the fit will be (see ?bart)}

\item{k}{the number of prior standard deviations E(Y|x) = f(x) is away from +/- 0.5.
The response is internally scaled to range from -0.5 to 0.5.
The bigger k is, the more conservative the fitting will be (see ?bart)}

\item{power}{power parameter for tree prior (see ?bart)}

\item{base}{base parameter for tree prior (see ?bart)}

\item{nsave}{number of MCMC iterations to save}

\item{nburn}{number of MCMC iterations to discard}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{verbose}{logical; if TRUE, print time remaining}
}
\value{
a list with the following elements:
\itemize{
\item \code{fitted.values}: the posterior mean of the conditional expectation of the counts \code{y}
\item \code{post.fitted.values}: posterior draws of the conditional mean of the counts \code{y}
\item \code{post.pred.test}: draws from the posterior predictive distribution at the test points \code{X_test}
\item \code{post.fitted.values.test}: posterior draws of the conditional mean at the test points \code{X_test}
\item \code{post.pred}: draws from the posterior predictive distribution of \code{y}
\item \code{post.lambda}: draws from the posterior distribution of \code{lambda}
\item \code{post.sigma}: draws from the posterior distribution of \code{sigma}
\item \code{post.mu.test}: draws of the conditional mean of z_star at the test points
\item \code{post.log.like.point}: draws of the log-likelihood for each of the \code{n} observations
\item \code{post.log.pred.test}: draws of the log-predictive distribution for each of the \code{n0} test cases
\item \code{logLik}: the log-likelihood evaluated at the posterior means
\item \code{WAIC}: Widely-Applicable/Watanabe-Akaike Information Criterion
\item \code{p_waic}: Effective number of parameters based on WAIC
}
}
\description{
Run the MCMC algorithm for a BART model for count-valued responses using STAR.
The transformation is from the Box-Cox family of transformations,
including identity, square-root, and logarthmic, as well as the Box-Cox
transformation with unknown parameter.
}
\examples{
\dontrun{
# Simulate data with count-valued response y:
sim_dat = simulate_nb_friedman(n = 100, p = 10)
y = sim_dat$y; X = sim_dat$X

# BART-STAR with log-transformation:
fit_bart_star_log = bart_star_MCMC(y = y, X = X, transformation = 'log')

# Fitted values
plot_fitted(y = sim_dat$Ey,
            post_y = fit_bart_star_log$post.fitted.values,
            main = 'Fitted Values: BART-STAR-log')

# WAIC for BART-STAR-log:
fit_bart_star_log$WAIC

# MCMC diagnostics:
plot(as.ts(fit_bart_star_log$post.fitted.values[,1:10]))

# Posterior predictive check:
hist(apply(fit_bart_star_log$post.pred, 1,
           function(x) mean(x==0)), main = 'Proportion of Zeros', xlab='');
abline(v = mean(y==0), lwd=4, col ='blue')

# BART-STAR with Box-Cox transformation:
fit_bart_star_bc = bart_star_MCMC(y = y, X = X, transformation = 'box-cox')

# Fitted values
plot_fitted(y = sim_dat$Ey,
            post_y = fit_bart_star_bc$post.fitted.values,
            main = 'Fitted Values: BART-STAR-bc')

# WAIC for BART-STAR-bc:
fit_bart_star_bc$WAIC

# MCMC diagnostics:
plot(as.ts(fit_bart_star_bc$post.fitted.values[,1:10]))

# Posterior predictive check:
hist(apply(fit_bart_star_bc$post.pred, 1,
           function(x) mean(x==0)), main = 'Proportion of Zeros', xlab='');
abline(v = mean(y==0), lwd=4, col ='blue')
}

}
