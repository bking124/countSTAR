% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/source_MCMC.R
\name{star_MCMC}
\alias{star_MCMC}
\title{MCMC Algorithm for STAR}
\usage{
star_MCMC(y, sample_params, init_params, transformation = "log",
  lambda = NULL, y_max = Inf, nsave = 5000, nburn = 5000,
  nskip = 2, save_y_hat = FALSE, verbose = TRUE)
}
\arguments{
\item{y}{\code{n x 1} vector of observed counts}

\item{sample_params}{a function that inputs data \code{y} and a named list \code{params} containing
\enumerate{
\item \code{mu}: the \code{n x 1} vector of conditional means (fitted values)
\item \code{sigma}: the conditional standard deviation
\item \code{coefficients}: a named list of parameters that determine \code{mu}
}
and outputs an updated list \code{params} of samples from the full conditional posterior
distribution of \code{coefficients} and \code{sigma} (and updates \code{mu})}

\item{init_params}{an initializing function that inputs data \code{y}
and initializes the named list \code{params} of \code{mu}, \code{sigma}, and \code{coefficients}}

\item{transformation}{transformation to use for the latent process; must be one of
\itemize{
\item "identity" (identity transformation)
\item "log" (log transformation)
\item "sqrt" (square root transformation)
\item "box-cox" (box-cox transformation)
}}

\item{lambda}{the nonlinear parameter for the Box-Cox transformation; if NULL, model as unknown}

\item{y_max}{a fixed and known upper bound for all observations; default is \code{Inf}}

\item{nsave}{number of MCMC iterations to save}

\item{nburn}{number of MCMC iterations to discard}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{save_y_hat}{logical; if TRUE, compute and save the posterior draws of
the expected counts, E(y), which may be slow to compute}

\item{verbose}{logical; if TRUE, print time remaining}
}
\value{
a list with the following elements:
\itemize{
\item \code{coefficients}: the posterior mean of the coefficients
\item \code{fitted.values}: the posterior mean of the conditional expectation of the counts \code{y}
\item \code{post.coefficients}: posterior draws of the coefficients
\item \code{post.fitted.values}: posterior draws of the conditional mean of the counts \code{y}
\item \code{post.pred}: draws from the posterior predictive distribution of \code{y}
\item \code{post.lambda}: draws from the posterior distribution of \code{lambda}
\item \code{post.sigma}: draws from the posterior distribution of \code{sigma}
\item \code{post.log.like.point}: draws of the log-likelihood for each of the \code{n} observations
\item \code{logLik}: the log-likelihood evaluated at the posterior means
\item \code{WAIC}: Widely-Applicable/Watanabe-Akaike Information Criterion
\item \code{p_waic}: Effective number of parameters based on WAIC
}
}
\description{
Run the MCMC algorithm for STAR given
\enumerate{
\item a function to initialize model parameters; and
\item a function to sample (i.e., update) model parameters.
}
The transformation is from the Box-Cox family of transformations,
including identity, square-root, and logarthmic, as well as the Box-Cox
transformation with unknown parameter.
}
\examples{
\dontrun{
# Simulate data with count-valued response y:
sim_dat = simulate_nb_lm(n = 100, p = 5)
y = sim_dat$y; X = sim_dat$X

# STAR: log-transformation:
fit_star_log = star_MCMC(y = y,
                         sample_params = function(y, params) sample_params_lm(y, X, params),
                         init_params = function(y) init_params_lm(y, X),
                         transformation = 'log')
# Posterior mean of each coefficient:
coef(fit_star_log)

# WAIC for STAR-log:
fit_star_log$WAIC

# MCMC diagnostics:
plot(as.ts(fit_star_log$post.coefficients[,1:3]))

# Posterior predictive check:
hist(apply(fit_star_log$post.pred, 1,
           function(x) mean(x==0)), main = 'Proportion of Zeros', xlab='');
abline(v = mean(y==0), lwd=4, col ='blue')

# STAR: unknown Box-Cox transformation
fit_star_bc = star_MCMC(y = y,
                        sample_params = function(y, params) sample_params_lm(y, X, params),
                        init_params = function(y) init_params_lm(y, X),
                        transformation = 'box-cox')
# Posterior mean of each coefficient:
coef(fit_star_bc)

# WAIC for STAR-bx:
fit_star_bc$WAIC

# MCMC diagnostics:
plot(as.ts(fit_star_bc$post.coefficients[,1:3]))

# Posterior predictive check:
hist(apply(fit_star_bc$post.pred, 1,
           function(x) mean(x==0)), main = 'Proportion of Zeros', xlab='');
abline(v = mean(y==0), lwd=4, col ='blue')

}
}
